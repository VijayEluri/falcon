#!/usr/bin/env python3
'''
Given a chroma file containing the contents of an LP,
identify all the tracks therein using Falcon.
Parameters:
- path to the LP chroma file
- path to the collection chroma files OR an index
- length/overlap of LP chunks
- length/overlap of track segments (the usual for coverID)
- transpositions
'''
import argparse, random, os, functools
import chromachunker, evaluation

def ranklist_score(l) :
    LEN = 4
    ll = list(filter(lambda x: len(x) == LEN, [l[i:min(len(l),i+LEN)] for i in range(len(l))]))
    ss = []
    for l in ll :
        s = 0
        for x in l :
            s += 1/(max(x,3)**2) if x else 1/(1000**2)
        ss.append(s)
    return max(ss) if len(ss) > 0 else 0


if __name__ == '__main__':
    # PARSE COMMAND LINE
    parser = argparse.ArgumentParser(description='identify tracks in an LP disc')
    parser.add_argument('--lp-chroma-file', help='path to chroma file for LP', required=True)
    parser.add_argument('--collection-index', help='path to the already indexed collection', required=True)
    parser.add_argument('--lp-chunk-length', type=int, help='LP chunk length', default=1800)
    parser.add_argument('--lp-chunk-overlap', type=int, help='LP chunk overlap', default=1200)
    parser.add_argument('--segment-length', help='segment length', default=300)
    parser.add_argument('--segment-overlap', help='segment overlap', default=150)
    collgroup2 = parser.add_mutually_exclusive_group(required=False)
    collgroup2.add_argument('--transpositions', help='number of transpositions', default=None)
    collgroup2.add_argument('--force-transposition', type=int, help='force a specific transposition in semitones', default=None)
    parser.add_argument('--subsampling', help='subsampling of chroma files', default=2)
    args = parser.parse_args()
    # working directory
    working_directory = 'lpid_tmp_%d' % random.randint(0,1000000)
    #working_directory = 'lpid_tmp_185518'
    if not os.path.exists(working_directory):
        os.makedirs(working_directory)
    # divide chroma file into chunks
    chromachunker.chunkfile(args.lp_chroma_file,working_directory,args.lp_chunk_length,args.lp_chunk_overlap)
    # do all queries
    qlistfile_path = os.path.join(working_directory, 'querylist.txt')
    qlistfile = open(qlistfile_path,'w')
    for qf in filter(lambda x : x.find('_chunk') > 0, os.listdir(working_directory)) :
        qlistfile.write('%s\n' % os.path.join(working_directory,qf))
    qlistfile.close()
    allqueriesres_path = os.path.join(working_directory, 'allqueries_res.txt')
    transp_arg = ''
    if args.transpositions :
        transp_arg = '-t %d' % args.transpositions 
    elif args.force_transposition :
        transp_arg = '-f %d' % args.force_transposition 
    querying_cmd = 'java -jar dist/falcon.jar -l %d -o %d %s -s %d %s -b < %s > %s' % (
        args.segment_length, args.segment_overlap, transp_arg,
        args.subsampling, args.collection_index, qlistfile_path, allqueriesres_path)
    print(querying_cmd)
    os.system(querying_cmd)
    # parse query results and produce final rank list
    res = evaluation.parseres(open(allqueriesres_path))
    queries = res.keys()
    allres = set(map(lambda x:x[0],functools.reduce(lambda x,y : x+y, [res[q] for q in queries])))
    restorank = {}
    for r in allres : restorank[r] = []
    for q in queries :
        usedres = []
        rank = 0
        for r in res[q] :
            usedres.append(r[0])
            rank += 1
            restorank[r[0]].append(rank)
        usedres=set(usedres)
        for r in allres :
            if r not in usedres :
                restorank[r].append(None)
    sortedallres = sorted(allres,key=lambda x : ranklist_score(restorank[x]), reverse=True)
    for res in sortedallres :
        print('[%6.4f] - %s' % (ranklist_score(restorank[res]),res))
